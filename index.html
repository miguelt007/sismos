<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <title>Tabela Sísmica IPMA (tempo real)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; }
    header { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 12px; }
    label { font-weight: 600; }
    input, select { padding: 6px 8px; }
    .status { font-size: 0.9rem; opacity: 0.8; }
    table { width: 100%; border-collapse: collapse; }
    thead th { position: sticky; top: 0; background: #f3f3f3; color: #222; z-index: 1; }
    th, td { border-bottom: 1px solid #e5e5e5; padding: 8px; text-align: left; vertical-align: top; }
    tbody tr:hover { background: #f9f9f9; }
    .muted { opacity: 0.7; font-size: 0.9em; }
    .error { color: #b00020; }
    .controls { display: flex; gap: 16px; align-items: center; flex-wrap: wrap; }
    .chip { display: inline-block; padding: 2px 6px; border-radius: 6px; background: #eef; color: #224; font-size: 0.85em; margin-left: 6px;}
  </style>
</head>
<body>
  <header>
    <h1 style="margin:0;">Sismicidade (IPMA) <span class="chip">tempo real</span></h1>
  </header>

  <div class="controls">
    <div>
      <label for="interval">Atualizar a cada</label>
      <select id="interval">
        <option value="10000">10 s</option>
        <option value="15000">15 s</option>
        <option value="30000" selected>30 s</option>
        <option value="60000">1 min</option>
        <option value="120000">2 min</option>
      </select>
    </div>
    <div>
      <label for="minMag">Magnitude mínima</label>
      <input id="minMag" type="number" step="0.1" value="0" style="width: 6rem;" />
    </div>
    <div class="status" id="status">Pronto</div>
  </div>

  <div id="error" class="error" role="alert" style="display:none;"></div>

  <div style="overflow:auto; max-width: 100%;">
    <table id="table">
      <thead></thead>
      <tbody></tbody>
    </table>
  </div>

  <script>
    const API_URL = 'https://api.ipma.pt/open-data/observation/seismic/7.json';
    const statusEl = document.getElementById('status');
    const errorEl = document.getElementById('error');
    const table = document.getElementById('table');
    const thead = table.querySelector('thead');
    const tbody = table.querySelector('tbody');
    const intervalSel = document.getElementById('interval');
    const minMagInput = document.getElementById('minMag');

    let timer = null;
    let lastSignature = '';

    function isLikelyDateKey(key) {
      const k = key.toLowerCase();
      return ['time','date','datetime','instant','origin','obs_time','tempo','data'].some(s => k.includes(s));
    }

    function parseDate(value) {
      // Tenta: ISO, epoch (ms/s), ou retorna null
      if (value == null) return null;
      if (typeof value === 'number') {
        const ms = value > 1e12 ? value : value * 1000;
        const d = new Date(ms);
        return isNaN(d) ? null : d;
      }
      if (typeof value === 'string') {
        const d = new Date(value);
        return isNaN(d) ? null : d;
      }
      return null;
    }

    function formatValue(key, value) {
      if (value == null) return '';
      if (isLikelyDateKey(key)) {
        const d = parseDate(value);
        if (d) {
          // Formata para hora local de Portugal
          return d.toLocaleString('pt-PT', { timeZone: 'Europe/Lisbon', hour12: false });
        }
      }
      if (typeof value === 'number') {
        // Magnitude com 1 decimal; profundidade com 0-1; resto com 2
        const k = key.toLowerCase();
        if (k.includes('mag')) return value.toFixed(1);
        if (k.includes('depth') || k.includes('prof')) return value.toFixed(value % 1 === 0 ? 0 : 1);
        return Number.isInteger(value) ? value.toString() : value.toFixed(2);
      }
      if (Array.isArray(value)) return value.join(', ');
      if (typeof value === 'object') return JSON.stringify(value);
      return String(value);
    }

    function deriveItems(json) {
      // Muitas APIs usam { data: [...] }. Caso contrário, pode já ser um array.
      if (Array.isArray(json)) return json;
      if (json && Array.isArray(json.data)) return json.data;
      if (json && Array.isArray(json.features)) return json.features.map(f => f.properties ?? f);
      // fallback: tenta converter objeto em array
      return [];
    }

    function buildColumns(items) {
      // Junta chaves dos primeiros N itens para garantir colunas
      const N = Math.min(items.length, 50);
      const set = new Set();
      for (let i = 0; i < N; i++) Object.keys(items[i]).forEach(k => set.add(k));
      const cols = Array.from(set);

      // Heurística: mover colunas “mais úteis” para o início
      const priority = ['time','date','datetime','instant','obs_time','mag','magnitude','lat','latitude','lon','lng','longitude','depth','prof'];
      cols.sort((a, b) => {
        const ai = priority.findIndex(p => a.toLowerCase().includes(p));
        const bi = priority.findIndex(p => b.toLowerCase().includes(p));
        const av = ai === -1 ? Number.POSITIVE_INFINITY : ai;
        const bv = bi === -1 ? Number.POSITIVE_INFINITY : bi;
        return av - bv || a.localeCompare(b);
      });
      return cols;
    }

    function renderTable(items) {
      if (!items.length) {
        thead.innerHTML = '';
        tbody.innerHTML = '<tr><td class="muted">Sem dados</td></tr>';
        return;
      }
      const cols = buildColumns(items);

      // Ordena por primeira coluna que pareça data/hora
      const dateCol = cols.find(isLikelyDateKey);
      if (dateCol) {
        items.sort((a, b) => {
          const da = parseDate(a[dateCol])?.getTime() ?? -Infinity;
          const db = parseDate(b[dateCol])?.getTime() ?? -Infinity;
          return db - da; // mais recente primeiro
        });
      }

      thead.innerHTML = '<tr>' + cols.map(c => `<th>${c}</th>`).join('') + '</tr>';
      tbody.innerHTML = items.map(row => {
        return '<tr>' + cols.map(c => `<td>${formatValue(c, row[c])}</td>`).join('') + '</tr>';
      }).join('');
    }

    function filterByMinMag(items, minMag) {
      if (!isFinite(minMag) || minMag <= 0) return items;
      // tenta encontrar um campo de magnitude
      const guessMagKey = items.length ? Object.keys(items[0]).find(k => k.toLowerCase().includes('mag')) : null;
      if (!guessMagKey) return items;
      return items.filter(it => {
        const v = Number(it[guessMagKey]);
        return !isNaN(v) && v >= minMag;
      });
    }

    async function fetchAndRender() {
      errorEl.style.display = 'none';
      statusEl.textContent = 'A atualizar...';
      const started = Date.now();
      try {
        const res = await fetch(API_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error('Resposta HTTP: ' + res.status);
        const json = await res.json();
        let items = deriveItems(json);

        // Filtro por magnitude (opcional)
        const minMag = parseFloat(minMagInput.value);
        items = filterByMinMag(items, minMag);

        // Evitar re-render desnecessário
        const signature = JSON.stringify(items.slice(0, 50)); // assinatura leve dos primeiros itens
        if (signature !== lastSignature) {
          renderTable(items);
          lastSignature = signature;
        }

        const elapsed = Date.now() - started;
        statusEl.textContent = `Atualizado ${new Date().toLocaleTimeString('pt-PT', { hour12: false })} (${items.length} registos, ${elapsed} ms)`;
      } catch (err) {
        console.error(err);
        errorEl.textContent = 'Falha ao obter dados: ' + err.message;
        errorEl.style.display = 'block';
        statusEl.textContent = 'Em espera (erro)';
      }
    }

    function startPolling() {
      if (timer) clearInterval(timer);
      timer = setInterval(fetchAndRender, Number(intervalSel.value));
    }

    intervalSel.addEventListener('change', () => {
      startPolling();
      fetchAndRender();
    });
    minMagInput.addEventListener('change', () => fetchAndRender());

    // Arranque
    fetchAndRender();
    startPolling();

    // Atualização manual com clique no status
    statusEl.style.cursor = 'pointer';
    statusEl.title = 'Clique para atualizar já';
    statusEl.addEventListener('click', fetchAndRender);
  </script>
</body>
</html>
